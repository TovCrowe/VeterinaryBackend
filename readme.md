# This is my learning curve and I hope is helpfull

Ill be explaining concepts of Java/Spring for this project with my own words, and of course this is based by the Java/Spring documentation 

## Making the models

Well to start, the project is based on my frontend project which is a Vet client managment, so to start I made my database in postgressql, you need to make the model on base with that
So to start I started using the @Entity notation

- Entity is based ton the JPA,this notation specifies that the class is mapped to a database table
- @Id specifies the primary key field int this case 'clienteID'
- @GeneratedValue indicates that the primary key value will be automatically generated by the DB
- @Table Specifies the name of the table in the database 

## Time to make the repository layer
So Im going to implement the repository pattern this pattern abstracts the data access and allows easy interaction with data sourcesm, this is implemented using spring data JPA

- JPArepository this is the most commonly used interface provided by spring data JPA. It privides several methods for CRUD operation and pagination

    - JpaRepository<T, ID>
        - T is the type of the entity
        - the type of the enetity primary key

this also has the @Repository notation this marks the interface as a repository, its not necessary BUT it is a good practice to use it

## Usage in service
The repositories are typically injected into service classes using @Autowired but in this case I used the constructor injection

## Constructor injection
Is a design pattern where the depencies are provide to a class throght the constructor
```java
private final PatientRepository patientRepository;

public PatientServiceImpl(PatientRepository patientRepository) {
    this.patientRepository = patientRepository;
}
```

## What is a service
In spring, a service is a classs that holds the business of an application and its typically marked with @Service which marks the class a service, this will make spring automatically detect and register it as a bean

## Service interface and service implementation

- The service interface works a contract that defines the methods for business operations, it specifies the actions the service can preform without providing all the logic

- The service implementation class provides the actual implementation of the methods defined by the service interface, it contains service logic and interacts with other components

## Controllers

Controllers in spring are defined using the @Controller or @RestController annotation, this is pretty straight forward so im just gonna explain the annotations

# Annotations in Spring CRUD Controller

## 1. `@PostMapping`

- **Usage**: Maps HTTP POST requests to a method.
- **Purpose**: Used to handle the creation of a new resource.
- **Example**: `@PostMapping` can be used to create a new patient in a database.

## 2. `@GetMapping`

- **Usage**: Maps HTTP GET requests to a method.
- **Purpose**: Used to retrieve resources.
- **Example**: `@GetMapping` can be used to fetch a list of all patients or a specific patient by ID.

## 3. `@PutMapping`

- **Usage**: Maps HTTP PUT requests to a method.
- **Purpose**: Used to update an existing resource.
- **Example**: `@PutMapping` can be used to update details of an existing patient.

## 4. `@DeleteMapping`

- **Usage**: Maps HTTP DELETE requests to a method.
- **Purpose**: Used to delete a resource.
- **Example**: `@DeleteMapping` can be used to remove a patient from the database by ID.

## 5. `@RequestBody`

- **Usage**: Binds the HTTP request body to a method parameter.
- **Purpose**: Used to pass data to a method from the request body (typically used with POST and PUT).
- **Example**: `@RequestBody PatientModel patientModel` binds the request body to a `PatientModel` object.

## 6. `@PathVariable`

- **Usage**: Binds a URL path segment to a method parameter.
- **Purpose**: Used to extract values from the URL and use them in the method (typically used with GET, PUT, DELETE).
- **Example**: `@PathVariable Long id` extracts the patient ID from the URL path.

## 7. `@ResponseStatus`

- **Usage**: Specifies the HTTP status code for a method.
- **Purpose**: Used to indicate the status of the response (e.g., 200 OK, 404 Not Found).
- **Example**: `@ResponseStatus(HttpStatus.NOT_FOUND)` can be used to return a 404 status for a resource not found.

## 8. `ResponseEntity<T>`

- **Usage**: Represents the entire HTTP response, including status code, headers, and body.
- **Purpose**: Allows control over the HTTP response status and body content.
- **Example**: `ResponseEntity.ok(patient)` returns an HTTP 200 status with the patient object as the body.


## Security Config

You might find some trouble at the moment on doing the POST, PUT methods, this is probably because the CSRF.

Disabling CSRF is generally not recommended unless you have a specific reason, such as if your application is an API where CSRF isn't applicable. If you're building a web application where users interact via browsers, you might want to configure CSRF protection properly.

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(request -> 
                request
                    .requestMatchers("/patients/**").permitAll()
                    .anyRequest().authenticated() // You may want to add this for other endpoints
            )
            .csrf(csrf -> csrf.disable()); // Consider removing or properly configuring CSRF
        return http.build();
    }
}

```
